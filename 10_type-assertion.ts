// 타입 단언(type assertion)
/**
 * 아래와 같이 a 값이 중간에
 * 여러 타입의 값들로 연산됨에 따라
 * 변수 a의 타입이 지속적으로 변경되고 있음.
 *
 * 그러나, 마지막 줄에서 b에 a를 할당할 때
 * a에 어떤 계산이 올 지 모르기 때문에
 * TS 랭귀지 서버는 a를 그냥 any 타입으로 추론해버림.
 *
 * 그에 따라, b 도 any 타입으로 추론됨.
 *
 * 그러나, 개발자들은 오히려
 * a의 값은 마지막에 할당된 'a' 이기 때문에,
 * 별도의 타입 추론이 없어도 a 에 담긴 값의 타입은 string 인 것을 알 수 있음.
 *
 * 따라서, 이럴 때에는 'a에 담긴 값은 문자열이다'
 * 라고 타입 단언을 하기 위해 사용하는 키워드가 as 라고 보면 됨.
 *
 * 이렇게 하면 a의 값이 담기는 b 의 타입이 string으로 변경됨.
 */
let a;
a = 20;
a = "a";
let b = a as string;

// 위의 예시대로 설명하면 와닿지 않겠지만,
// 타입 단언은 실제로 DOM API 조작 시 가장 많이 사용됨.
// 얘도 TS 랭귀지 서버에 의해 리턴값이 HTMLDivElement 로 타입 추론됨!
const div = document.querySelector("div") as HTMLDivElement; // 또는 타입 단언을 통해 저 div 변수가 null 이 아니라는 것을 보장할 수도 있음.
// if (div) {
//  근데 DOM 트리에 div 요소가 없을수도 있기 때문에,
//  리턴값의 타입은 HTMLDivElement | null 이런 식으로 null 이 나올 수도 있음.
//  그래서 만약 DOM API 를 아래와 같이 사용하고 싶다면,
//  저 div 변수가 null 이 아니라는걸 한 번 보장해주는 작업이 필요한데,
//  이런 식으로 if 조건문을 통해서 해줄 수도 있고,
//  위와 같이 as 키워드로 타입단언을 해서 null 이 아님을 보장할 수 있음.
//   div.innerText;
// }
div.innerText; // 타입 단언으로 null 이 아님을 보장해줬다면, 조건문 밖에서도 마음껏 DOM API 에 접근 가능!

/**
 * 타입 단언에 대해서 결론적으로 정리하면,
 *
 * "개발자인 내가 TS 랭귀지 서버보다 현재 타입에 대해서 더 잘 알고 있다.
 * 따라서 타입은 내가 알아서 선언을 할테니 TS 서버는 건들지 말아라"
 *
 * 라고 하면서 개발자가 자의적으로 타입을 단언하는 것이라고 보면 됨.
 */
